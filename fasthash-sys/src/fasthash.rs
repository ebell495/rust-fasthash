/* automatically generated by rust-bindgen 0.59.2 */

pub type conditional_type<_If> = _If;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type pair_first_type<_T1> = _T1;
pub type pair_second_type<_T2> = _T2;
pub type pair__EnableB = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair__CheckArgs {
    pub _address: u8,
}
pub type pair__CheckArgsDep = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair__CheckTupleLikeConstructor {
    pub _address: u8,
}
pub type pair__CheckTLC = u8;
pub type uint32 = u32;
pub type uint64 = u64;
pub type uint128 = pair<uint64, uint64>;
extern "C" {
    #[link_name = "\u{1}__Z18CityHash32WithSeedPKcmj"]
    pub fn CityHash32WithSeed(
        buf: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint32,
    ) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}__Z10CityHash64PKcm"]
    pub fn CityHash64(buf: *const ::std::os::raw::c_char, len: usize) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}__Z18CityHash64WithSeedPKcmy"]
    pub fn CityHash64WithSeed(
        buf: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint64,
    ) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}__Z19CityHash64WithSeedsPKcmyy"]
    pub fn CityHash64WithSeeds(
        buf: *const ::std::os::raw::c_char,
        len: usize,
        seed0: uint64,
        seed1: uint64,
    ) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}__Z11CityHash128PKcm"]
    pub fn CityHash128(s: *const ::std::os::raw::c_char, len: usize) -> uint128;
}
extern "C" {
    #[link_name = "\u{1}__Z19CityHash128WithSeedPKcmNSt3__14pairIyyEE"]
    pub fn CityHash128WithSeed(
        s: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint128,
    ) -> uint128;
}
extern "C" {
    #[link_name = "\u{1}__Z14CityHashCrc128PKcm"]
    pub fn CityHashCrc128(s: *const ::std::os::raw::c_char, len: usize) -> uint128;
}
extern "C" {
    #[link_name = "\u{1}__Z22CityHashCrc128WithSeedPKcmNSt3__14pairIyyEE"]
    pub fn CityHashCrc128WithSeed(
        s: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint128,
    ) -> uint128;
}
extern "C" {
    #[link_name = "\u{1}__Z14CityHashCrc256PKcmPy"]
    pub fn CityHashCrc256(s: *const ::std::os::raw::c_char, len: usize, result: *mut uint64);
}
extern "C" {
    #[link_name = "\u{1}__Z13metrohash64_1PKhyjPh"]
    pub fn metrohash64_1(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z13metrohash64_2PKhyjPh"]
    pub fn metrohash64_2(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z16metrohash64crc_1PKhyjPh"]
    pub fn metrohash64crc_1(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z16metrohash64crc_2PKhyjPh"]
    pub fn metrohash64crc_2(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z14metrohash128_1PKhyjPh"]
    pub fn metrohash128_1(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z14metrohash128_2PKhyjPh"]
    pub fn metrohash128_2(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z17metrohash128crc_1PKhyjPh"]
    pub fn metrohash128crc_1(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z17metrohash128crc_2PKhyjPh"]
    pub fn metrohash128crc_2(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z11MurmurHash1PKvij"]
    pub fn MurmurHash1(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z18MurmurHash1AlignedPKvij"]
    pub fn MurmurHash1Aligned(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z11MurmurHash2PKvij"]
    pub fn MurmurHash2(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z13MurmurHash64APKviy"]
    pub fn MurmurHash64A(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u64,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z13MurmurHash64BPKviy"]
    pub fn MurmurHash64B(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u64,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z12MurmurHash2APKvij"]
    pub fn MurmurHash2A(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z18MurmurHashNeutral2PKvij"]
    pub fn MurmurHashNeutral2(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z18MurmurHashAligned2PKvij"]
    pub fn MurmurHashAligned2(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z18MurmurHash3_x86_32PKvijPv"]
    pub fn MurmurHash3_x86_32(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
        out: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z19MurmurHash3_x86_128PKvijPv"]
    pub fn MurmurHash3_x86_128(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
        out: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z19MurmurHash3_x64_128PKvijPv"]
    pub fn MurmurHash3_x64_128(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
        out: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Obtains the xxHash version."]
    #[doc = ""]
    #[doc = " This is mostly useful when xxHash is compiled as a shared library,"]
    #[doc = " since the returned value comes from the library, as opposed to header file."]
    #[doc = ""]
    #[doc = " @return @ref XXH_VERSION_NUMBER of the invoked library."]
    pub fn XXH_versionNumber() -> ::std::os::raw::c_uint;
}
#[doc = "< OK"]
pub const XXH_errorcode_XXH_OK: XXH_errorcode = 0;
#[doc = "< Error"]
pub const XXH_errorcode_XXH_ERROR: XXH_errorcode = 1;
#[doc = " @brief Exit code for the streaming API."]
pub type XXH_errorcode = ::std::os::raw::c_uint;
pub type XXH32_hash_t = u32;
extern "C" {
    #[doc = " @brief Calculates the 32-bit hash of @p input using xxHash32."]
    #[doc = ""]
    #[doc = " Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s"]
    #[doc = ""]
    #[doc = " See @ref single_shot_example \"Single Shot Example\" for an example."]
    #[doc = ""]
    #[doc = " @param input The block of data to be hashed, at least @p length bytes in size."]
    #[doc = " @param length The length of @p input, in bytes."]
    #[doc = " @param seed The 32-bit seed to alter the hash's output predictably."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   The memory between @p input and @p input + @p length must be valid,"]
    #[doc = "   readable, contiguous memory. However, if @p length is `0`, @p input may be"]
    #[doc = "   `NULL`. In C++, this also must be *TriviallyCopyable*."]
    #[doc = ""]
    #[doc = " @return The calculated 32-bit hash value."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = "    XXH64(), XXH3_64bits_withSeed(), XXH3_128bits_withSeed(), XXH128():"]
    #[doc = "    Direct equivalents for the other variants of xxHash."]
    #[doc = " @see"]
    #[doc = "    XXH32_createState(), XXH32_update(), XXH32_digest(): Streaming version."]
    pub fn XXH32(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: XXH32_hash_t,
    ) -> XXH32_hash_t;
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH32 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is"]
#[doc = " an opaque type. This allows fields to safely be changed."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH32_state_t."]
#[doc = " Do not access the members of this struct directly."]
#[doc = " @see XXH64_state_s, XXH3_state_s"]
pub type XXH32_state_t = XXH32_state_s;
extern "C" {
    #[doc = " @brief Allocates an @ref XXH32_state_t."]
    #[doc = ""]
    #[doc = " Must be freed with XXH32_freeState()."]
    #[doc = " @return An allocated XXH32_state_t on success, `NULL` on failure."]
    pub fn XXH32_createState() -> *mut XXH32_state_t;
}
extern "C" {
    #[doc = " @brief Frees an @ref XXH32_state_t."]
    #[doc = ""]
    #[doc = " Must be allocated with XXH32_createState()."]
    #[doc = " @param statePtr A pointer to an @ref XXH32_state_t allocated with @ref XXH32_createState()."]
    #[doc = " @return XXH_OK."]
    pub fn XXH32_freeState(statePtr: *mut XXH32_state_t) -> XXH_errorcode;
}
extern "C" {
    #[doc = " @brief Copies one @ref XXH32_state_t to another."]
    #[doc = ""]
    #[doc = " @param dst_state The state to copy to."]
    #[doc = " @param src_state The state to copy from."]
    #[doc = " @pre"]
    #[doc = "   @p dst_state and @p src_state must not be `NULL` and must not overlap."]
    pub fn XXH32_copyState(dst_state: *mut XXH32_state_t, src_state: *const XXH32_state_t);
}
extern "C" {
    #[doc = " @brief Resets an @ref XXH32_state_t to begin a new hash."]
    #[doc = ""]
    #[doc = " This function resets and seeds a state. Call it before @ref XXH32_update()."]
    #[doc = ""]
    #[doc = " @param statePtr The state struct to reset."]
    #[doc = " @param seed The 32-bit seed to alter the hash result predictably."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   @p statePtr must not be `NULL`."]
    #[doc = ""]
    #[doc = " @return @ref XXH_OK on success, @ref XXH_ERROR on failure."]
    pub fn XXH32_reset(statePtr: *mut XXH32_state_t, seed: XXH32_hash_t) -> XXH_errorcode;
}
extern "C" {
    #[doc = " @brief Consumes a block of @p input to an @ref XXH32_state_t."]
    #[doc = ""]
    #[doc = " Call this to incrementally consume blocks of data."]
    #[doc = ""]
    #[doc = " @param statePtr The state struct to update."]
    #[doc = " @param input The block of data to be hashed, at least @p length bytes in size."]
    #[doc = " @param length The length of @p input, in bytes."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   @p statePtr must not be `NULL`."]
    #[doc = " @pre"]
    #[doc = "   The memory between @p input and @p input + @p length must be valid,"]
    #[doc = "   readable, contiguous memory. However, if @p length is `0`, @p input may be"]
    #[doc = "   `NULL`. In C++, this also must be *TriviallyCopyable*."]
    #[doc = ""]
    #[doc = " @return @ref XXH_OK on success, @ref XXH_ERROR on failure."]
    pub fn XXH32_update(
        statePtr: *mut XXH32_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    #[doc = " @brief Returns the calculated hash value from an @ref XXH32_state_t."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   Calling XXH32_digest() will not affect @p statePtr, so you can update,"]
    #[doc = "   digest, and update again."]
    #[doc = ""]
    #[doc = " @param statePtr The state struct to calculate the hash from."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "  @p statePtr must not be `NULL`."]
    #[doc = ""]
    #[doc = " @return The calculated xxHash32 value from that state."]
    pub fn XXH32_digest(statePtr: *const XXH32_state_t) -> XXH32_hash_t;
}
#[doc = " @brief Canonical (big endian) representation of @ref XXH32_hash_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH32_canonical_t {
    #[doc = "< Hash bytes, big endian"]
    pub digest: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_XXH32_canonical_t() {
    assert_eq!(
        ::std::mem::size_of::<XXH32_canonical_t>(),
        4usize,
        concat!("Size of: ", stringify!(XXH32_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH32_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH32_canonical_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_canonical_t>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    #[doc = " @brief Converts an @ref XXH32_hash_t to a big endian @ref XXH32_canonical_t."]
    #[doc = ""]
    #[doc = " @param dst The @ref XXH32_canonical_t pointer to be stored to."]
    #[doc = " @param hash The @ref XXH32_hash_t to be converted."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   @p dst must not be `NULL`."]
    pub fn XXH32_canonicalFromHash(dst: *mut XXH32_canonical_t, hash: XXH32_hash_t);
}
extern "C" {
    #[doc = " @brief Converts an @ref XXH32_canonical_t to a native @ref XXH32_hash_t."]
    #[doc = ""]
    #[doc = " @param src The @ref XXH32_canonical_t to convert."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   @p src must not be `NULL`."]
    #[doc = ""]
    #[doc = " @return The converted hash."]
    pub fn XXH32_hashFromCanonical(src: *const XXH32_canonical_t) -> XXH32_hash_t;
}
pub type XXH64_hash_t = u64;
extern "C" {
    #[doc = " @brief Calculates the 64-bit hash of @p input using xxHash64."]
    #[doc = ""]
    #[doc = " This function usually runs faster on 64-bit systems, but slower on 32-bit"]
    #[doc = " systems (see benchmark)."]
    #[doc = ""]
    #[doc = " @param input The block of data to be hashed, at least @p length bytes in size."]
    #[doc = " @param length The length of @p input, in bytes."]
    #[doc = " @param seed The 64-bit seed to alter the hash's output predictably."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   The memory between @p input and @p input + @p length must be valid,"]
    #[doc = "   readable, contiguous memory. However, if @p length is `0`, @p input may be"]
    #[doc = "   `NULL`. In C++, this also must be *TriviallyCopyable*."]
    #[doc = ""]
    #[doc = " @return The calculated 64-bit hash."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = "    XXH32(), XXH3_64bits_withSeed(), XXH3_128bits_withSeed(), XXH128():"]
    #[doc = "    Direct equivalents for the other variants of xxHash."]
    #[doc = " @see"]
    #[doc = "    XXH64_createState(), XXH64_update(), XXH64_digest(): Streaming version."]
    pub fn XXH64(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: XXH64_hash_t,
    ) -> XXH64_hash_t;
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH64 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is"]
#[doc = " an opaque type. This allows fields to safely be changed."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH64_state_t."]
#[doc = " Do not access the members of this struct directly."]
#[doc = " @see XXH32_state_s, XXH3_state_s"]
pub type XXH64_state_t = XXH64_state_s;
extern "C" {
    pub fn XXH64_createState() -> *mut XXH64_state_t;
}
extern "C" {
    pub fn XXH64_freeState(statePtr: *mut XXH64_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_copyState(dst_state: *mut XXH64_state_t, src_state: *const XXH64_state_t);
}
extern "C" {
    pub fn XXH64_reset(statePtr: *mut XXH64_state_t, seed: XXH64_hash_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_update(
        statePtr: *mut XXH64_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_digest(statePtr: *const XXH64_state_t) -> XXH64_hash_t;
}
#[doc = "   Canonical representation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH64_canonical_t {
    pub digest: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_XXH64_canonical_t() {
    assert_eq!(
        ::std::mem::size_of::<XXH64_canonical_t>(),
        8usize,
        concat!("Size of: ", stringify!(XXH64_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH64_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH64_canonical_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_canonical_t>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    pub fn XXH64_canonicalFromHash(dst: *mut XXH64_canonical_t, hash: XXH64_hash_t);
}
extern "C" {
    pub fn XXH64_hashFromCanonical(src: *const XXH64_canonical_t) -> XXH64_hash_t;
}
extern "C" {
    #[doc = " @brief 64-bit unseeded variant of XXH3."]
    #[doc = ""]
    #[doc = " This is equivalent to @ref XXH3_64bits_withSeed() with a seed of 0, however"]
    #[doc = " it may have slightly better performance due to constant propagation of the"]
    #[doc = " defaults."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = "    XXH32(), XXH64(), XXH3_128bits(): equivalent for the other xxHash algorithms"]
    #[doc = " @see"]
    #[doc = "    XXH3_64bits_withSeed(), XXH3_64bits_withSecret(): other seeding variants"]
    #[doc = " @see"]
    #[doc = "    XXH3_64bits_reset(), XXH3_64bits_update(), XXH3_64bits_digest(): Streaming version."]
    pub fn XXH3_64bits(input: *const ::std::os::raw::c_void, length: usize) -> XXH64_hash_t;
}
extern "C" {
    #[doc = " @brief 64-bit seeded variant of XXH3"]
    #[doc = ""]
    #[doc = " This variant generates a custom secret on the fly based on default secret"]
    #[doc = " altered using the `seed` value."]
    #[doc = ""]
    #[doc = " While this operation is decently fast, note that it's not completely free."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "    seed == 0 produces the same results as @ref XXH3_64bits()."]
    #[doc = ""]
    #[doc = " @param input The data to hash"]
    #[doc = " @param length The length"]
    #[doc = " @param seed The 64-bit seed to alter the state."]
    pub fn XXH3_64bits_withSeed(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: XXH64_hash_t,
    ) -> XXH64_hash_t;
}
extern "C" {
    #[doc = " @brief 64-bit variant of XXH3 with a custom \"secret\"."]
    #[doc = ""]
    #[doc = " It's possible to provide any blob of bytes as a \"secret\" to generate the hash."]
    #[doc = " This makes it more difficult for an external actor to prepare an intentional collision."]
    #[doc = " The main condition is that secretSize *must* be large enough (>= XXH3_SECRET_SIZE_MIN)."]
    #[doc = " However, the quality of the secret impacts the dispersion of the hash algorithm."]
    #[doc = " Therefore, the secret _must_ look like a bunch of random bytes."]
    #[doc = " Avoid \"trivial\" or structured data such as repeated sequences or a text document."]
    #[doc = " Whenever in doubt about the \"randomness\" of the blob of bytes,"]
    #[doc = " consider employing \"XXH3_generateSecret()\" instead (see below)."]
    #[doc = " It will generate a proper high entropy secret derived from the blob of bytes."]
    #[doc = " Another advantage of using XXH3_generateSecret() is that"]
    #[doc = " it guarantees that all bits within the initial blob of bytes"]
    #[doc = " will impact every bit of the output."]
    #[doc = " This is not necessarily the case when using the blob of bytes directly"]
    #[doc = " because, when hashing _small_ inputs, only a portion of the secret is employed."]
    pub fn XXH3_64bits_withSecret(
        data: *const ::std::os::raw::c_void,
        len: usize,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
    ) -> XXH64_hash_t;
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH3 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined."]
#[doc = " Otherwise it is an opaque type."]
#[doc = " Never use this definition in combination with dynamic library."]
#[doc = " This allows fields to safely be changed in the future."]
#[doc = ""]
#[doc = " @note ** This structure has a strict alignment requirement of 64 bytes!! **"]
#[doc = " Do not allocate this with `malloc()` or `new`,"]
#[doc = " it will not be sufficiently aligned."]
#[doc = " Use @ref XXH3_createState() and @ref XXH3_freeState(), or stack allocation."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH3_state_t."]
#[doc = " Do never access the members of this struct directly."]
#[doc = ""]
#[doc = " @see XXH3_INITSTATE() for stack initialization."]
#[doc = " @see XXH3_createState(), XXH3_freeState()."]
#[doc = " @see XXH32_state_s, XXH64_state_s"]
pub type XXH3_state_t = XXH3_state_s;
extern "C" {
    pub fn XXH3_createState() -> *mut XXH3_state_t;
}
extern "C" {
    pub fn XXH3_freeState(statePtr: *mut XXH3_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_copyState(dst_state: *mut XXH3_state_t, src_state: *const XXH3_state_t);
}
extern "C" {
    pub fn XXH3_64bits_reset(statePtr: *mut XXH3_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_64bits_reset_withSeed(
        statePtr: *mut XXH3_state_t,
        seed: XXH64_hash_t,
    ) -> XXH_errorcode;
}
extern "C" {
    #[doc = " XXH3_64bits_reset_withSecret():"]
    #[doc = " `secret` is referenced, it _must outlive_ the hash streaming session."]
    #[doc = " Similar to one-shot API, `secretSize` must be >= `XXH3_SECRET_SIZE_MIN`,"]
    #[doc = " and the quality of produced hash values depends on secret's entropy"]
    #[doc = " (secret's content should look like a bunch of random bytes)."]
    #[doc = " When in doubt about the randomness of a candidate `secret`,"]
    #[doc = " consider employing `XXH3_generateSecret()` instead (see below)."]
    pub fn XXH3_64bits_reset_withSecret(
        statePtr: *mut XXH3_state_t,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_64bits_update(
        statePtr: *mut XXH3_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_64bits_digest(statePtr: *const XXH3_state_t) -> XXH64_hash_t;
}
#[doc = " @brief The return value from 128-bit hashes."]
#[doc = ""]
#[doc = " Stored in little endian order, although the fields themselves are in native"]
#[doc = " endianness."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH128_hash_t {
    #[doc = "< `value & 0xFFFFFFFFFFFFFFFF`"]
    pub low64: XXH64_hash_t,
    #[doc = "< `value >> 64`"]
    pub high64: XXH64_hash_t,
}
#[test]
fn bindgen_test_layout_XXH128_hash_t() {
    assert_eq!(
        ::std::mem::size_of::<XXH128_hash_t>(),
        16usize,
        concat!("Size of: ", stringify!(XXH128_hash_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH128_hash_t>(),
        8usize,
        concat!("Alignment of ", stringify!(XXH128_hash_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH128_hash_t>())).low64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH128_hash_t),
            "::",
            stringify!(low64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH128_hash_t>())).high64 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH128_hash_t),
            "::",
            stringify!(high64)
        )
    );
}
extern "C" {
    #[doc = " @brief Unseeded 128-bit variant of XXH3"]
    #[doc = ""]
    #[doc = " The 128-bit variant of XXH3 has more strength, but it has a bit of overhead"]
    #[doc = " for shorter inputs."]
    #[doc = ""]
    #[doc = " This is equivalent to @ref XXH3_128bits_withSeed() with a seed of 0, however"]
    #[doc = " it may have slightly better performance due to constant propagation of the"]
    #[doc = " defaults."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = "    XXH32(), XXH64(), XXH3_64bits(): equivalent for the other xxHash algorithms"]
    #[doc = " @see"]
    #[doc = "    XXH3_128bits_withSeed(), XXH3_128bits_withSecret(): other seeding variants"]
    #[doc = " @see"]
    #[doc = "    XXH3_128bits_reset(), XXH3_128bits_update(), XXH3_128bits_digest(): Streaming version."]
    pub fn XXH3_128bits(data: *const ::std::os::raw::c_void, len: usize) -> XXH128_hash_t;
}
extern "C" {
    #[doc = " @brief Seeded 128-bit variant of XXH3. @see XXH3_64bits_withSeed()."]
    pub fn XXH3_128bits_withSeed(
        data: *const ::std::os::raw::c_void,
        len: usize,
        seed: XXH64_hash_t,
    ) -> XXH128_hash_t;
}
extern "C" {
    #[doc = " @brief Custom secret 128-bit variant of XXH3. @see XXH3_64bits_withSecret()."]
    pub fn XXH3_128bits_withSecret(
        data: *const ::std::os::raw::c_void,
        len: usize,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
    ) -> XXH128_hash_t;
}
extern "C" {
    pub fn XXH3_128bits_reset(statePtr: *mut XXH3_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_128bits_reset_withSeed(
        statePtr: *mut XXH3_state_t,
        seed: XXH64_hash_t,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_128bits_reset_withSecret(
        statePtr: *mut XXH3_state_t,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_128bits_update(
        statePtr: *mut XXH3_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_128bits_digest(statePtr: *const XXH3_state_t) -> XXH128_hash_t;
}
extern "C" {
    #[doc = " XXH128_isEqual():"]
    #[doc = " Return: 1 if `h1` and `h2` are equal, 0 if they are not."]
    pub fn XXH128_isEqual(h1: XXH128_hash_t, h2: XXH128_hash_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compares two @ref XXH128_hash_t"]
    #[doc = " This comparator is compatible with stdlib's `qsort()`/`bsearch()`."]
    #[doc = ""]
    #[doc = " @return: >0 if *h128_1  > *h128_2"]
    #[doc = "          =0 if *h128_1 == *h128_2"]
    #[doc = "          <0 if *h128_1  < *h128_2"]
    pub fn XXH128_cmp(
        h128_1: *const ::std::os::raw::c_void,
        h128_2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = "   Canonical representation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH128_canonical_t {
    pub digest: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_XXH128_canonical_t() {
    assert_eq!(
        ::std::mem::size_of::<XXH128_canonical_t>(),
        16usize,
        concat!("Size of: ", stringify!(XXH128_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH128_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH128_canonical_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH128_canonical_t>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH128_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    pub fn XXH128_canonicalFromHash(dst: *mut XXH128_canonical_t, hash: XXH128_hash_t);
}
extern "C" {
    pub fn XXH128_hashFromCanonical(src: *const XXH128_canonical_t) -> XXH128_hash_t;
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH32 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is"]
#[doc = " an opaque type. This allows fields to safely be changed."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH32_state_t."]
#[doc = " Do not access the members of this struct directly."]
#[doc = " @see XXH64_state_s, XXH3_state_s"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH32_state_s {
    #[doc = "< Total length hashed, modulo 2^32"]
    pub total_len_32: XXH32_hash_t,
    #[doc = "< Whether the hash is >= 16 (handles @ref total_len_32 overflow)"]
    pub large_len: XXH32_hash_t,
    #[doc = "< Accumulator lanes"]
    pub v: [XXH32_hash_t; 4usize],
    #[doc = "< Internal buffer for partial reads. Treated as unsigned char[16]."]
    pub mem32: [XXH32_hash_t; 4usize],
    #[doc = "< Amount of data in @ref mem32"]
    pub memsize: XXH32_hash_t,
    #[doc = "< Reserved field. Do not read nor write to it."]
    pub reserved: XXH32_hash_t,
}
#[test]
fn bindgen_test_layout_XXH32_state_s() {
    assert_eq!(
        ::std::mem::size_of::<XXH32_state_s>(),
        48usize,
        concat!("Size of: ", stringify!(XXH32_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH32_state_s>(),
        4usize,
        concat!("Alignment of ", stringify!(XXH32_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).total_len_32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(total_len_32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).large_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(large_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).v as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).mem32 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(mem32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).memsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(memsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH64 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is"]
#[doc = " an opaque type. This allows fields to safely be changed."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH64_state_t."]
#[doc = " Do not access the members of this struct directly."]
#[doc = " @see XXH32_state_s, XXH3_state_s"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH64_state_s {
    #[doc = "< Total length hashed. This is always 64-bit."]
    pub total_len: XXH64_hash_t,
    #[doc = "< Accumulator lanes"]
    pub v: [XXH64_hash_t; 4usize],
    #[doc = "< Internal buffer for partial reads. Treated as unsigned char[32]."]
    pub mem64: [XXH64_hash_t; 4usize],
    #[doc = "< Amount of data in @ref mem64"]
    pub memsize: XXH32_hash_t,
    #[doc = "< Reserved field, needed for padding anyways"]
    pub reserved32: XXH32_hash_t,
    #[doc = "< Reserved field. Do not read or write to it."]
    pub reserved64: XXH64_hash_t,
}
#[test]
fn bindgen_test_layout_XXH64_state_s() {
    assert_eq!(
        ::std::mem::size_of::<XXH64_state_s>(),
        88usize,
        concat!("Size of: ", stringify!(XXH64_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH64_state_s>(),
        8usize,
        concat!("Alignment of ", stringify!(XXH64_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).total_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(total_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).v as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).mem64 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(mem64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).memsize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(memsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).reserved32 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(reserved32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).reserved64 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(reserved64)
        )
    );
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH3 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined."]
#[doc = " Otherwise it is an opaque type."]
#[doc = " Never use this definition in combination with dynamic library."]
#[doc = " This allows fields to safely be changed in the future."]
#[doc = ""]
#[doc = " @note ** This structure has a strict alignment requirement of 64 bytes!! **"]
#[doc = " Do not allocate this with `malloc()` or `new`,"]
#[doc = " it will not be sufficiently aligned."]
#[doc = " Use @ref XXH3_createState() and @ref XXH3_freeState(), or stack allocation."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH3_state_t."]
#[doc = " Do never access the members of this struct directly."]
#[doc = ""]
#[doc = " @see XXH3_INITSTATE() for stack initialization."]
#[doc = " @see XXH3_createState(), XXH3_freeState()."]
#[doc = " @see XXH32_state_s, XXH64_state_s"]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct XXH3_state_s {
    pub acc: [XXH64_hash_t; 8usize],
    pub customSecret: [::std::os::raw::c_uchar; 192usize],
    pub buffer: [::std::os::raw::c_uchar; 256usize],
    pub bufferedSize: XXH32_hash_t,
    pub useSeed: XXH32_hash_t,
    pub nbStripesSoFar: usize,
    pub totalLen: XXH64_hash_t,
    pub nbStripesPerBlock: usize,
    pub secretLimit: usize,
    pub seed: XXH64_hash_t,
    pub reserved64: XXH64_hash_t,
    pub extSecret: *const ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_XXH3_state_s() {
    assert_eq!(
        ::std::mem::size_of::<XXH3_state_s>(),
        576usize,
        concat!("Size of: ", stringify!(XXH3_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH3_state_s>(),
        64usize,
        concat!("Alignment of ", stringify!(XXH3_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).acc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(acc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).customSecret as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(customSecret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).buffer as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).bufferedSize as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(bufferedSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).useSeed as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(useSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).nbStripesSoFar as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(nbStripesSoFar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).totalLen as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(totalLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).nbStripesPerBlock as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(nbStripesPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).secretLimit as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(secretLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).seed as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).reserved64 as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(reserved64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).extSecret as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(extSecret)
        )
    );
}
extern "C" {
    #[doc = " simple alias to pre-selected XXH3_128bits variant"]
    pub fn XXH128(
        data: *const ::std::os::raw::c_void,
        len: usize,
        seed: XXH64_hash_t,
    ) -> XXH128_hash_t;
}
extern "C" {
    #[doc = " XXH3_generateSecret():"]
    #[doc = ""]
    #[doc = " Derive a high-entropy secret from any user-defined content, named customSeed."]
    #[doc = " The generated secret can be used in combination with `*_withSecret()` functions."]
    #[doc = " The `_withSecret()` variants are useful to provide a higher level of protection"]
    #[doc = " than 64-bit seed, as it becomes much more difficult for an external actor to"]
    #[doc = " guess how to impact the calculation logic."]
    #[doc = ""]
    #[doc = " The function accepts as input a custom seed of any length and any content,"]
    #[doc = " and derives from it a high-entropy secret of length @p secretSize into an"]
    #[doc = " already allocated buffer @p secretBuffer."]
    #[doc = ""]
    #[doc = " The generated secret can then be used with any `*_withSecret()` variant."]
    #[doc = " The functions @ref XXH3_128bits_withSecret(), @ref XXH3_64bits_withSecret(),"]
    #[doc = " @ref XXH3_128bits_reset_withSecret() and @ref XXH3_64bits_reset_withSecret()"]
    #[doc = " are part of this list. They all accept a `secret` parameter"]
    #[doc = " which must be large enough for implementation reasons (>= @ref XXH3_SECRET_SIZE_MIN)"]
    #[doc = " _and_ feature very high entropy (consist of random-looking bytes)."]
    #[doc = " These conditions can be a high bar to meet, so @ref XXH3_generateSecret() can"]
    #[doc = " be employed to ensure proper quality."]
    #[doc = ""]
    #[doc = " @p customSeed can be anything. It can have any size, even small ones,"]
    #[doc = " and its content can be anything, even \"poor entropy\" sources such as a bunch"]
    #[doc = " of zeroes. The resulting `secret` will nonetheless provide all required qualities."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   - @p secretSize must be >= @ref XXH3_SECRET_SIZE_MIN"]
    #[doc = "   - When @p customSeedSize > 0, supplying NULL as customSeed is undefined behavior."]
    #[doc = ""]
    #[doc = " Example code:"]
    #[doc = " @code{.c}"]
    #[doc = "    #include <stdio.h>"]
    #[doc = "    #include <stdlib.h>"]
    #[doc = "    #include <string.h>"]
    #[doc = "    #define XXH_STATIC_LINKING_ONLY // expose unstable API"]
    #[doc = "    #include \"xxhash.h\""]
    #[doc = "    // Hashes argv[2] using the entropy from argv[1]."]
    #[doc = "    int main(int argc, char* argv[])"]
    #[doc = "    {"]
    #[doc = "        char secret[XXH3_SECRET_SIZE_MIN];"]
    #[doc = "        if (argv != 3) { return 1; }"]
    #[doc = "        XXH3_generateSecret(secret, sizeof(secret), argv[1], strlen(argv[1]));"]
    #[doc = "        XXH64_hash_t h = XXH3_64bits_withSecret("]
    #[doc = "             argv[2], strlen(argv[2]),"]
    #[doc = "             secret, sizeof(secret)"]
    #[doc = "        );"]
    #[doc = "        printf(\"%016llx\\n\", (unsigned long long) h);"]
    #[doc = "    }"]
    #[doc = " @endcode"]
    pub fn XXH3_generateSecret(
        secretBuffer: *mut ::std::os::raw::c_void,
        secretSize: usize,
        customSeed: *const ::std::os::raw::c_void,
        customSeedSize: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    #[doc = " @brief Generate the same secret as the _withSeed() variants."]
    #[doc = ""]
    #[doc = " The generated secret can be used in combination with"]
    #[doc = "`*_withSecret()` and `_withSecretandSeed()` variants."]
    #[doc = ""]
    #[doc = " Example C++ `std::string` hash class:"]
    #[doc = " @code{.cpp}"]
    #[doc = "    #include <string>"]
    #[doc = "    #define XXH_STATIC_LINKING_ONLY // expose unstable API"]
    #[doc = "    #include \"xxhash.h\""]
    #[doc = "    // Slow, seeds each time"]
    #[doc = "    class HashSlow {"]
    #[doc = "        XXH64_hash_t seed;"]
    #[doc = "    public:"]
    #[doc = "        HashSlow(XXH64_hash_t s) : seed{s} {}"]
    #[doc = "        size_t operator()(const std::string& x) const {"]
    #[doc = "            return size_t{XXH3_64bits_withSeed(x.c_str(), x.length(), seed)};"]
    #[doc = "        }"]
    #[doc = "    };"]
    #[doc = "    // Fast, caches the seeded secret for future uses."]
    #[doc = "    class HashFast {"]
    #[doc = "        unsigned char secret[XXH3_SECRET_SIZE_MIN];"]
    #[doc = "    public:"]
    #[doc = "        HashFast(XXH64_hash_t s) {"]
    #[doc = "            XXH3_generateSecret_fromSeed(secret, seed);"]
    #[doc = "        }"]
    #[doc = "        size_t operator()(const std::string& x) const {"]
    #[doc = "            return size_t{"]
    #[doc = "                XXH3_64bits_withSecret(x.c_str(), x.length(), secret, sizeof(secret))"]
    #[doc = "            };"]
    #[doc = "        }"]
    #[doc = "    };"]
    #[doc = " @endcode"]
    #[doc = " @param secretBuffer A writable buffer of @ref XXH3_SECRET_SIZE_MIN bytes"]
    #[doc = " @param seed The seed to seed the state."]
    pub fn XXH3_generateSecret_fromSeed(
        secretBuffer: *mut ::std::os::raw::c_void,
        seed: XXH64_hash_t,
    );
}
extern "C" {
    #[doc = " These variants generate hash values using either"]
    #[doc = " @p seed for \"short\" keys (< XXH3_MIDSIZE_MAX = 240 bytes)"]
    #[doc = " or @p secret for \"large\" keys (>= XXH3_MIDSIZE_MAX)."]
    #[doc = ""]
    #[doc = " This generally benefits speed, compared to `_withSeed()` or `_withSecret()`."]
    #[doc = " `_withSeed()` has to generate the secret on the fly for \"large\" keys."]
    #[doc = " It's fast, but can be perceptible for \"not so large\" keys (< 1 KB)."]
    #[doc = " `_withSecret()` has to generate the masks on the fly for \"small\" keys,"]
    #[doc = " which requires more instructions than _withSeed() variants."]
    #[doc = " Therefore, _withSecretandSeed variant combines the best of both worlds."]
    #[doc = ""]
    #[doc = " When @p secret has been generated by XXH3_generateSecret_fromSeed(),"]
    #[doc = " this variant produces *exactly* the same results as `_withSeed()` variant,"]
    #[doc = " hence offering only a pure speed benefit on \"large\" input,"]
    #[doc = " by skipping the need to regenerate the secret for every large input."]
    #[doc = ""]
    #[doc = " Another usage scenario is to hash the secret to a 64-bit hash value,"]
    #[doc = " for example with XXH3_64bits(), which then becomes the seed,"]
    #[doc = " and then employ both the seed and the secret in _withSecretandSeed()."]
    #[doc = " On top of speed, an added benefit is that each bit in the secret"]
    #[doc = " has a 50% chance to swap each bit in the output, via its impact to the seed."]
    #[doc = ""]
    #[doc = " This is not guaranteed when using the secret directly in \"small data\" scenarios,"]
    #[doc = " because only portions of the secret are employed for small data."]
    pub fn XXH3_64bits_withSecretandSeed(
        data: *const ::std::os::raw::c_void,
        len: usize,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
        seed: XXH64_hash_t,
    ) -> XXH64_hash_t;
}
extern "C" {
    #[doc = " @copydoc XXH3_64bits_withSecretandSeed()"]
    pub fn XXH3_128bits_withSecretandSeed(
        input: *const ::std::os::raw::c_void,
        length: usize,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
        seed64: XXH64_hash_t,
    ) -> XXH128_hash_t;
}
extern "C" {
    #[doc = " @copydoc XXH3_64bits_withSecretandSeed()"]
    pub fn XXH3_64bits_reset_withSecretandSeed(
        statePtr: *mut XXH3_state_t,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
        seed64: XXH64_hash_t,
    ) -> XXH_errorcode;
}
extern "C" {
    #[doc = " @copydoc XXH3_64bits_withSecretandSeed()"]
    pub fn XXH3_128bits_reset_withSecretandSeed(
        statePtr: *mut XXH3_state_t,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
        seed64: XXH64_hash_t,
    ) -> XXH_errorcode;
}
extern "C" {
    #[link_name = "\u{1}__Z7lookup3PKcij"]
    pub fn lookup3(
        key: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        initval: u32,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint128_c_t {
    pub a: u64,
    pub b: u64,
}
#[test]
fn bindgen_test_layout_uint128_c_t() {
    assert_eq!(
        ::std::mem::size_of::<uint128_c_t>(),
        16usize,
        concat!("Size of: ", stringify!(uint128_c_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uint128_c_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uint128_c_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint128_c_t>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint128_c_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint128_c_t>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uint128_c_t),
            "::",
            stringify!(b)
        )
    );
}
extern "C" {
    pub fn farmhash(s: *const ::std::os::raw::c_char, len: usize) -> usize;
}
extern "C" {
    pub fn farmhash32(s: *const ::std::os::raw::c_char, len: usize) -> u32;
}
extern "C" {
    pub fn farmhash32_with_seed(s: *const ::std::os::raw::c_char, len: usize, seed: u32) -> u32;
}
extern "C" {
    pub fn farmhash64(s: *const ::std::os::raw::c_char, len: usize) -> u64;
}
extern "C" {
    pub fn farmhash64_with_seed(s: *const ::std::os::raw::c_char, len: usize, seed: u64) -> u64;
}
extern "C" {
    pub fn farmhash64_with_seeds(
        s: *const ::std::os::raw::c_char,
        len: usize,
        seed0: u64,
        seed1: u64,
    ) -> u64;
}
extern "C" {
    pub fn farmhash128(s: *const ::std::os::raw::c_char, len: usize) -> uint128_c_t;
}
extern "C" {
    pub fn farmhash128_with_seed(
        s: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint128_c_t,
    ) -> uint128_c_t;
}
extern "C" {
    pub fn farmhash_fingerprint32(s: *const ::std::os::raw::c_char, len: usize) -> u32;
}
extern "C" {
    pub fn farmhash_fingerprint64(s: *const ::std::os::raw::c_char, len: usize) -> u64;
}
extern "C" {
    pub fn farmhash_fingerprint128(s: *const ::std::os::raw::c_char, len: usize) -> uint128_c_t;
}
extern "C" {
    #[link_name = "\u{1}__Z28farmhash_fingerprint_uint12811uint128_c_t"]
    pub fn farmhash_fingerprint_uint128(x: uint128_c_t) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z27farmhash_fingerprint_uint64y"]
    pub fn farmhash_fingerprint_uint64(x: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z10komihash64PKvmy"]
    pub fn komihash64(Msg0: *const ::std::os::raw::c_void, MsgLen: usize, UseSeed: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z10komirand64PyS_"]
    pub fn komirand64(Seed1: *mut u64, Seed2: *mut u64) -> u64;
}
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
extern "C" {
    #[link_name = "\u{1}__ZL15MeowShiftAdjust"]
    pub static mut MeowShiftAdjust: [::std::os::raw::c_uchar; 32usize];
}
extern "C" {
    #[link_name = "\u{1}__ZL11MeowMaskLen"]
    pub static mut MeowMaskLen: [::std::os::raw::c_uchar; 32usize];
}
extern "C" {
    #[link_name = "\u{1}__ZL15MeowDefaultSeed"]
    pub static mut MeowDefaultSeed: [::std::os::raw::c_uchar; 128usize];
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct meow_state {
    pub xmm0: __m128i,
    pub xmm1: __m128i,
    pub xmm2: __m128i,
    pub xmm3: __m128i,
    pub xmm4: __m128i,
    pub xmm5: __m128i,
    pub xmm6: __m128i,
    pub xmm7: __m128i,
    pub TotalLengthInBytes: ::std::os::raw::c_ulonglong,
    pub BufferLen: ::std::os::raw::c_uint,
    pub Buffer: [::std::os::raw::c_uchar; 256usize],
    pub Pad: [__m128i; 2usize],
}
#[test]
fn bindgen_test_layout_meow_state() {
    assert_eq!(
        ::std::mem::size_of::<meow_state>(),
        432usize,
        concat!("Size of: ", stringify!(meow_state))
    );
    assert_eq!(
        ::std::mem::align_of::<meow_state>(),
        16usize,
        concat!("Alignment of ", stringify!(meow_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm4 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm5 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm6 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm7 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).TotalLengthInBytes as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(TotalLengthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).BufferLen as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(BufferLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).Buffer as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).Pad as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(Pad)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__Z11MeowHash128PKviPvS1_"]
    pub fn MeowHash128(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: *mut ::std::os::raw::c_void,
        out: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z13MeowHashBeginP10meow_statePv"]
    pub fn MeowHashBegin(State: *mut meow_state, Seed128: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__Z14MeowHashUpdateP10meow_statemPv"]
    pub fn MeowHashUpdate(
        State: *mut meow_state,
        Len: usize,
        SourceInit: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z11MeowHashEndP10meow_statePv"]
    pub fn MeowHashEnd(State: *mut meow_state, out: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__Z18MeowHashExpandSeedyPvPh"]
    pub fn MeowHashExpandSeed(
        InputLen: ::std::os::raw::c_ulonglong,
        Input: *mut ::std::os::raw::c_void,
        SeedResult: *mut ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z9mum_hash_PKvmy"]
    pub fn mum_hash_(key: *const ::std::os::raw::c_void, len: usize, seed: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z16SpookyHasherHashPKvmPyS1_"]
    pub fn SpookyHasherHash(
        message: *const ::std::os::raw::c_void,
        length: usize,
        hash1: *mut uint64,
        hash2: *mut uint64,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z15SpookyHasherNewv"]
    pub fn SpookyHasherNew() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}__Z16SpookyHasherFreePv"]
    pub fn SpookyHasherFree(h: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__Z16SpookyHasherInitPvyy"]
    pub fn SpookyHasherInit(h: *mut ::std::os::raw::c_void, seed1: uint64, seed2: uint64);
}
extern "C" {
    #[link_name = "\u{1}__Z18SpookyHasherUpdatePvPKvm"]
    pub fn SpookyHasherUpdate(
        h: *mut ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z17SpookyHasherFinalPvPyS0_"]
    pub fn SpookyHasherFinal(
        h: *mut ::std::os::raw::c_void,
        hash1: *mut uint64,
        hash2: *mut uint64,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union t1ha_state256 {
    pub bytes: [u8; 32usize],
    pub u32_: [u32; 8usize],
    pub u64_: [u64; 4usize],
    pub n: t1ha_state256__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t1ha_state256__bindgen_ty_1 {
    pub a: u64,
    pub b: u64,
    pub c: u64,
    pub d: u64,
}
#[test]
fn bindgen_test_layout_t1ha_state256__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<t1ha_state256__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(t1ha_state256__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<t1ha_state256__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(t1ha_state256__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256__bindgen_ty_1>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256__bindgen_ty_1),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256__bindgen_ty_1>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256__bindgen_ty_1>())).c as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256__bindgen_ty_1),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256__bindgen_ty_1>())).d as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
}
#[test]
fn bindgen_test_layout_t1ha_state256() {
    assert_eq!(
        ::std::mem::size_of::<t1ha_state256>(),
        32usize,
        concat!("Size of: ", stringify!(t1ha_state256))
    );
    assert_eq!(
        ::std::mem::align_of::<t1ha_state256>(),
        8usize,
        concat!("Alignment of ", stringify!(t1ha_state256))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256>())).u32_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256),
            "::",
            stringify!(n)
        )
    );
}
pub type t1ha_state256_t = t1ha_state256;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct t1ha_context {
    pub state: t1ha_state256_t,
    pub buffer: t1ha_state256_t,
    pub partial: usize,
    pub total: u64,
}
#[test]
fn bindgen_test_layout_t1ha_context() {
    assert_eq!(
        ::std::mem::size_of::<t1ha_context>(),
        96usize,
        concat!("Size of: ", stringify!(t1ha_context))
    );
    assert_eq!(
        ::std::mem::align_of::<t1ha_context>(),
        32usize,
        concat!("Alignment of ", stringify!(t1ha_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_context>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_context>())).buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_context>())).partial as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_context),
            "::",
            stringify!(partial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_context>())).total as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_context),
            "::",
            stringify!(total)
        )
    );
}
pub type t1ha_context_t = t1ha_context;
extern "C" {
    pub fn t1ha2_atonce(data: *const ::std::os::raw::c_void, length: usize, seed: u64) -> u64;
}
extern "C" {
    pub fn t1ha2_atonce128(
        extra_result: *mut u64,
        data: *const ::std::os::raw::c_void,
        length: usize,
        seed: u64,
    ) -> u64;
}
extern "C" {
    pub fn t1ha2_init(ctx: *mut t1ha_context_t, seed_x: u64, seed_y: u64);
}
extern "C" {
    pub fn t1ha2_update(
        ctx: *mut t1ha_context_t,
        data: *const ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    pub fn t1ha2_final(ctx: *mut t1ha_context_t, extra_result: *mut u64) -> u64;
}
extern "C" {
    pub fn t1ha1_le(data: *const ::std::os::raw::c_void, length: usize, seed: u64) -> u64;
}
extern "C" {
    pub fn t1ha1_be(data: *const ::std::os::raw::c_void, length: usize, seed: u64) -> u64;
}
pub type t1ha0_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: usize, arg3: u64) -> u64,
>;
extern "C" {
    pub fn t1ha0_resolve() -> t1ha0_function_t;
}
extern "C" {
    #[link_name = "\u{1}__Z8t1ha0_64PKvmy"]
    pub fn t1ha0_64(data: *const ::std::os::raw::c_void, length: usize, seed: u64) -> u64;
}
pub type HHKey = [u64; 4usize];
pub type HHResult128 = [u64; 2usize];
pub type HHResult256 = [u64; 4usize];
extern "C" {
    pub fn HighwayHash64(key: *mut u64, bytes: *const ::std::os::raw::c_char, size: u64) -> u64;
}
extern "C" {
    pub fn HighwayHash64_TargetPortable(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
    ) -> u64;
}
extern "C" {
    pub fn HighwayHash64_TargetSSE41(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
    ) -> u64;
}
extern "C" {
    pub fn HighwayHash64_TargetAVX2(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
    ) -> u64;
}
extern "C" {
    pub fn HighwayHash64_TargetVSX(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z14HighwayHash128PKyPKcyRA2_y"]
    pub fn HighwayHash128(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
        hash: *mut HHResult128,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z14HighwayHash256PKyPKcyRA4_y"]
    pub fn HighwayHash256(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
        hash: *mut HHResult256,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z8wyhash64PKvyy"]
    pub fn wyhash64(key: *const ::std::os::raw::c_void, len: u64, seed: u64) -> u64;
}
#[test]
fn __bindgen_test_layout_pair_open0_uint64_uint64_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<pair<uint64, uint64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (pair < uint64 , uint64 >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pair<uint64, uint64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (pair < uint64 , uint64 >)
        )
    );
}
